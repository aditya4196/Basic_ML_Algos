# -*- coding: utf-8 -*-
"""Regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kcN8B6Qz9_w5ACNR2BeFCM8cIxHUOKaE
"""

import sklearn
import numpy as np
import scipy as sp
import pandas as pd

import matplotlib.pyplot as plt

import seaborn as sns

housing_data = pd.read_csv('sample_data/housing.csv')

housing_data.head()

housing_data.describe()

housing_data['ocean_proximity'].unique()

fig, ax = plt.subplots(figsize=(12,8))
plt.scatter(housing_data['total_rooms'], housing_data['median_house_value'])
plt.xlabel('Total Rooms')
plt.ylabel('Median House Values')

fig, ax = plt.subplots(figsize=(12,8))
plt.scatter(housing_data['housing_median_age'], housing_data['median_house_value'])
plt.xlabel('Median Age')
plt.ylabel('Median House Values')

fig, ax = plt.subplots(figsize=(12,8))
plt.scatter(housing_data['median_income']*10000, housing_data['median_house_value'])
plt.xlabel('Median Age')
plt.ylabel('Median House Values')

housing_data_corr = housing_data.corr()
housing_data_corr

fig, ax = plt.subplots(figsize = (12,8))
sns.heatmap(housing_data_corr,annot=True)

"""Linear Regression for Price Prediction"""

import pandas as pd
import matplotlib.pyplot as plt

housing_data.sample(5)

housing_data.loc[housing_data['median_house_value']==500001].count()

housing_data = housing_data.drop(housing_data.loc[housing_data['median_house_value']==500001].index)

housing_data.shape

housing_data['ocean_proximity'].unique()

"""Convert categorical values to numeric values using one-hot encoding"""

housing_data = pd.get_dummies(housing_data, columns=['ocean_proximity'])

housing_data.shape

"""Below code in the cell to clean NaN, Infinite values, or negative infinite values"""

import numpy as np
assert isinstance(housing_data, pd.DataFrame), "df needs to be a pd.DataFrame"
housing_data.dropna(inplace=True)
indices_to_keep = ~housing_data.isin([np.nan, np.inf, -np.inf]).any(1)
housing_data =  housing_data[indices_to_keep].astype(np.float64)

housing_data.shape



X = housing_data.drop('median_house_value', axis = 1)
Y = housing_data['median_house_value']



X.columns

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(X,Y,test_size=0.2)

x_train.shape, x_test.shape

y_train.shape, y_test.shape

"""Estimator to train the model"""

from sklearn.linear_model import LinearRegression
linear_model = LinearRegression(normalize=True).fit(x_train,y_train)

print("Training Score : ", linear_model.score(x_train, y_train))

"""Coefficient for each feature tells how much that feature contributed to the training"""

coef = pd.Series(linear_model.coef_, x_train.columns).sort_values()
print(coef)

"""Predict the x test data using the trained model"""

y_pred = linear_model.predict(x_test)

df_pred_actual = pd.DataFrame({'predicted' : y_pred, 'actual' : y_test})

df_pred_actual.head(10)

from sklearn.metrics import r2_score
 print("Testing Score : ", r2_score(y_test, y_pred) )

fig, ax = plt.subplots(figsize = (12,8))
plt.scatter(y_test, y_pred)
plt.show()

df_pred_actual_sample = df_pred_actual.sample(100)
df_pred_actual_sample = df_pred_actual_sample.reset_index()

plt.figure(figsize = (20,10))
plt.plot(df_pred_actual_sample['predicted'], label = 'Predicted')
plt.plot(df_pred_actual_sample['actual'], label = 'Actual')
plt.ylabel('median_house_value')
plt.legend()
plt.show()

"""Logistic Regression"""

housing_data.shape

median = housing_data['median_house_value'].median()

median

housing_data['above_median'] = (housing_data['median_house_value'] - median) > 0

housing_data.sample(5)

X = housing_data.drop(['median_house_value', 'above_median'], axis = 1)
Y = housing_data['above_median']



from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(X,Y,test_size=0.2)

"""'liblinear' is one of the logisticregression algorithm which is good for small dataset and for binary classification"""

from sklearn.linear_model import LogisticRegression
logistic_model = LogisticRegression(solver='liblinear').fit(x_train,y_train)





























